#!/usr/bin/env ruby
# frozen_string_literal: true

require "rubygems"
require "commander/import"
require "fileutils"
require "pry"
require "file-tail"
require "dotenv"
require "active_support"
require "active_support/all"
require "colorize"

program :name, 'esm'
program :version, '0.0.1'
program :description, 'CLI utility to build @esm'

command :build do |c|
  c.syntax = 'esm build [options]'
  c.summary = 'Builds the extension for ESM.'
  c.description = 'Builds the extension for ESM.'
  c.option '--use-x86', 'Build the x32 version of the extension'
  c.option '--target=TARGET', String, 'The target OS to build to. Valid options: linux, windows. Defaults to: windows'
  c.option '--release', 'Build for release to public'
  c.action do |args, options|
    build_target = (options.target || "windows").to_sym
    next say("Invalid build target. Valid options are: linux, windows") if ![:linux, :windows].include?(build_target)

    Dotenv.load("./tools/esm.#{build_target}.env")

    build_arch = options.use_x86 ? :x86 : :x64
    build_env = options.release ? :release : :debug

    say("Building ESM with target:#{build_target} arch:#{build_arch} env:#{build_env}")

    # Set some build flags
    Utils.flags(target: build_target, arch: build_arch, env: build_env)

    # Clean up the build and destination directories
    Utils.clean_directories

    # Compile and copy over the DLL into the @esm mod locally
    Utils.build_and_copy_extension

    # Build and copy the mod to destination
    Utils.build_and_copy_mod
  end
end

command :run do |c|
  c.syntax = 'esm run [options]'
  c.summary = ''
  c.description = ''
  c.example 'description', 'command example'
  c.option '--use-x86', 'Build the x32 version of the extension and start the x32 version of the server'
  c.option '--target=TARGET', String, 'The target OS to build to. Valid options: linux, windows. Defaults to: windows'
  c.option '--release', 'Build for release to public'
  c.action do |args, options|
    build_target = (options.target || "windows").to_sym
    next say("Invalid build target. Valid options are: linux, windows") if ![:linux, :windows].include?(build_target)

    Dotenv.load("./tools/esm.#{build_target}.env")

    build_arch = options.use_x86 ? :x86 : :x64
    build_env = options.release ? :release : :debug

    say("Building ESM with target:#{build_target} arch:#{build_arch} env:#{build_env}")

    # Set some build flags
    Utils.flags(target: build_target, arch: build_arch, env: build_env)

    # Check for required stuff
    next say("Server path is missing, please set it using `ESM_SERVER_PATH` environment variable") if Utils.config.server_directory.empty?
    next say("Deployment path is missing, please set it using `ESM_DEPLOY_PATH` environment variable") if Utils.deploy_directory.empty?

    # Kill Arma server
    Utils.kill_arma_server

    # Clean up the build and destination directories
    Utils.clean_directories

    # Compile and copy over the DLL into the @esm mod locally
    Utils.build_and_copy_extension

    # Build and copy the mod to destination
    Utils.build_and_copy_mod

    # Start the server
    Utils.start_server

    # Pull up the logs
    Utils.open_logs
  end
end

class Utils
  ADDONS = [
    "exile_server_manager",
    "exile_server_overwrites",
    "exile_server_xm8",
    "exile_server_hacking",
    "exile_server_grinding",
    "exile_server_charge_plant_started",
    "exile_server_flag_steal_started",
    "exile_server_player_connected"
  ].freeze

  TARGETS = {
    windows: {
      x86: "i686-pc-windows-msvc",
      x64: "x86_64-pc-windows-msvc"
    },
    linux: {
      x86: "i686-unknown-linux-gnu",
      x64: "x86_64-unknown-linux-gnu"
    }
  }.freeze

  def self.config
    @config ||= OpenStruct.new(
      extension_directory: File.expand_path("./"),
      build_directory: File.expand_path("./target/arma"),
      server_directory: ENV["ESM_SERVER_PATH"],
      mikeros_directory: ENV["ESM_MIKEROS_PATH"],
      build_script_x86: ENV["ESM_BUILD_SCRIPT_X86"],
      build_script_x64: ENV["ESM_BUILD_SCRIPT_X64"],
      remote_host: ENV["ESM_REMOTE_HOST"],
    ).freeze
  end

  def self.say(message, &block)
    puts message.colorize(:blue)
    yield
    puts "done".colorize(:blue)
  end

  def self.remote_execute(command, ssh_options: {})
    options = ssh_options.map { |option, value| "-o \"#{option}=#{value}\"" }.join(" ")

    puts "\t[#{config.remote_host} #{options}]: #{command}".colorize(:light_black)
    `ssh #{config.remote_host} #{options} #{command}`
  end

  def self.flags(target:, arch:, env:)
    @target = target
    @arch = arch
    @env = env
  end

  def self.build_target
    @build_target ||= TARGETS[@target][@arch]
  end

  def self.deploy_directory
    @deploy_directory ||= lambda do
      path = ENV["ESM_DEPLOY_PATH"] || ""
      return "" if path.empty?

      if @arch == :x64
        path + "_x64"
      else
        path
      end
    end.call
  end

  def self.temp_directory
    @temp_directory ||= lambda do
      temp_directory =
        if @target == :windows
          resolved_dir = remote_execute("echo %Temp%").strip.gsub("\\", "/")
          "#{resolved_dir}/esm_arma"
        else
          "/tmp/esm_arma"
        end

      # Create the temp directory
      command =
        if @target == :windows

        else
        end

      temp_directory
    end.call
  end

  def self.kill_arma_server
    say "Killing Arma server" do
      arch = @arch == :x64 ? "_x64" : ""

      command =
        if @target == :windows
          "taskkill /IM \"arma3server#{arch}.exe\" /F"
        else
          "killall arma3server#{arch}"
        end

      remote_execute(command)
    end
  end

  def self.clean_directories
    say "Cleaning directories..." do
      # Remove the @esm in target/arma
      if File.directory?("#{config.build_directory}/@esm")
        remove_dir("#{config.build_directory}/@esm")
      end

      # Recreate the directory
      FileUtils.mkdir_p("#{config.build_directory}/@esm")

      # Copy the @esm into target/arma (Except addons)
      copy("#{config.extension_directory}/@esm", config.build_directory)

      # Create the addons folder in target/arma/@esm
      FileUtils.mkdir_p("#{config.build_directory}/@esm/addons")

      # Remove src in case of file changes
      remove_dir("#{temp_directory}/src") if path_exist?("#{temp_directory}/src")
    end
  end

  def self.build_and_copy_extension
    build_extension
    copy_extension
  end

  def self.build_extension
    say "Building extension..." do
      # Copy the extension over to the host to allow building the extension natively
      [
        "src", ".cargo", "Cargo.toml", "diesel.toml", "Win32.def"
      ].each do |item|
        copy("#{config.extension_directory}/#{item}", temp_directory, remote_destination: true)
      end

      command = "cd #{temp_directory} && cargo build --target #{build_target}"
      command += " --release" if @env == :release

      remote_execute("\"#{command}\"")
    end
  end

  def self.copy_extension
    say "Copying extension..." do
      source_ext_name = @target == :windows ? "esm.dll" : "libesm.so"
      destination_ext_name = @target == :windows ? "esm#{@target == :x64 ? '_x64' : ''}.dll" : "esm.so"

      source_ext = "#{temp_directory}/target/#{build_target}/#{@env}/#{source_ext_name}"
      command = "copy /y #{source_ext} #{deploy_directory}/@esm/#{destination_ext_name}"
      remote_execute(command)
    end
  end

  def self.build_and_copy_mod
    build_addons
    copy_mod
  end

  def self.build_addons
    say "Building addons..." do
      ADDONS.each do |addon|
        path = "#{config.build_directory}/@esm/addons/#{addon}"
        `makepbo -PW -@=#{addon} "#{path}"`
        remove_dir(path)
      end
    end
  end

  def self.copy_mod
    say "Copying mod..." do
      # Remove the @esm mod in the destination
      remove_dir("#{deploy_directory}/@esm", remote_path: true) if path_exist?("#{deploy_directory}/@esm", remote_path: true)
      copy("#{config.build_directory}/@esm", deploy_directory, remote_destination: true)
    end
  end

  def self.start_server
    say "Starting server..." do
      script = config.send("build_script_#{@arch}")

      command =
        if @target == :windows
          script = { program_name: script.gsub("\\", "\\\\\\"), arguments: [] }.to_json

          #"curl -H \\\"Content-Type: application/json\\\" -d '#{script}' localhost:3030/run"
          
        else
          <<~STRING
            cd #{config.server_directory} && \
            rm -rf @esm && \
            rm -rf @exile && \
            rm -rf @exileserver && \
            rm -rf mpmissions && \
            cp -r #{deploy_directory}/* #{config.server_directory}/ && \
            #{script}
          STRING
        end

      remote_execute(command, ssh_options: { ServerAliveInterval: 240, ServerAliveCountMax: 2 })
    end
  end

  def self.remove_dir(path, remote_path: false)
    return FileUtils.remove_dir(path) if !remote_path

    command =
      if @target == :windows
        path = path.gsub("/", "\\")
        "rmdir \"#{path}\" /s /q"
      else
        "rm -rf \"#{path}\""
      end

    remote_execute(command)
  end

  def self.copy(source_path, destination_path, remote_destination: false, file: false)
    if remote_destination
      `scp #{file ? "" : "-r"} #{source_path} #{config.remote_host}:/#{destination_path}`
    else
      FileUtils.cp_r(source_path, destination_path)
    end
  end

  def self.path_exist?(path, remote_path: false, target: @target)
    return File.exist?(path) if !remote_path

    if target == :windows
      remote_execute("if exist #{path} echo True") == "True"
    else
      remote_execute('test -f #{path} && echo "true" || echo "false"') == "true"
    end
  end

  def self.open_logs
    say "Opening logs" do
      path = "#{config.server_directory}/@esm/log/esm.log"
      25.times do
        next sleep(1) if !path_exist?(path, remote_path: true)

        remote_execute("tail -f #{path}")
      end

      puts "Failed to open esm.log"
    rescue SystemExit, Interrupt
      kill_arma_server
      exit
    end
  end
end
